import torch
import torch.nn as nn
import torch.optim as optim


X = torch.tensor([
    [5.1, 3.5, 1.4, 0.2],
    [4.9, 3.0, 1.4, 0.2],
    [6.2, 3.4, 5.4, 2.3],
    [5.9, 3.0, 5.1, 1.8],
    [5.5, 2.3, 4.0, 1.3],
    [6.5, 2.8, 4.6, 1.5],
], dtype=torch.float32)

y = torch.tensor([
    0,
    0,
    2,
    2,
    1,
    1
], dtype=torch.long)

class MES(nn.Module) :
    def __init__(self):
        super().__init__()
        self.fc1 = nn.Linear(4,16)
        self.fc2 = nn.Linear(16,16)
        self.fc3 = nn.Linear(16,3)
    def forward(self,x) :
        x = torch.relu(self.fc1(x))
        x = torch.relu(self.fc2(x))
        x = self.fc3(x)
        return x

model = MES()

Fu_loss = nn.CrossEntropyLoss()

optimizer = optim.SGD(model.parameters(), lr = 0.05)

epochs = 10000

for epoch in range(epochs) :

    optimizer.zero_grad()

    y_perd = model(X)

    loss = Fu_loss(y_perd , y)

    loss.backward()

    optimizer.step()

    if epoch % 1000 == 0 :
        print(f"epoch :{epoch}")
        print (f"loss :{loss.item()}")
with torch.no_grad() :
   prediction = model(X)
   print("\npredicction")
   predicted_classes = torch.argmax(prediction, dim=1)
   print(predicted_classes)
